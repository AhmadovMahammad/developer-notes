3. Dockerfile-ın anatomiyası: kontekst, laylar, multi-stage
-----------------------------------------------------------

Digərləri barədə məlumatı az da olsa digər əvvəlki sectionlarda almışıq.
Ona görə də bu sectionda biz əsas olaraq fokuslanaclıq nginx üzərinə.
--------------------------------------------------

1. Nginx nədir?

Nginx bir web server proqramıdır. 
Əsas işi budur ki: HTTP sorğularını qəbul eləsin və uyğun cavabı geri versin.

Məsələn, brauzerdə `http://localhost` yazanda sorğu Nginx-ə gəlir. 
O isə `root` dediyim qovluğun içində həmin faylı axtarır. 
`GET /` gəlirsə → `index.html` qaytarır, `GET /style.css` gəlirsə → `style.css` qaytarır.

Amma Nginx təkcə “fayl verən” deyil. O həm də:

Statik faylları (HTML, CSS, JS, şəkillər) çox sürətli verir.
Reverse proxy ola bilir (sorğunu API-yə ötürmək üçün).
URL-ləri yönləndirmək, alias, redirect, rewrite kimi qaydaları bacarır.
Load balancer ola bilir (bir sorğunu bir neçə serverə paylaya bilir).
HTTPS təmin edir (TLS/SSL ilə).
Performansı artırmaq üçün gzip, brotli, cache kimi funksiyalar əlavə edir.

Mənim indi öyrəndiklərim əsasən onun statik fayl verən hissəsi və URL idarəetmə qaydalarıdır.

Mənim fayl strukturu

```
C:\Users\mahammada\Documents\test-nginx
│   index.html
│   style.css
│
├── languages\
│     (burda HTML fayl var)
│
└── names\
      (burda HTML fayl var)
```

Bu qovluq mənim üçün root oldu. Yəni:

`http://localhost/` → `index.html` açılır.
`http://localhost/style.css` → `style.css` faylı gəlir.
`http://localhost/languages/` → `languages\index.html` varsa, o verilir.


Konfiqurasiyanın izahı

```nginx
events {}
http {
    include mime.types;

    server {
        listen 80;
        server_name localhost;
        root "C:\\Users\\mahammada\\Documents\\test-nginx";
        index index.html;
```

`listen 80` - Nginx 80 portunda qulaq asır, yəni adi HTTP portudur.
`server_name localhost` - bu konfiq localhost üçün işləyir.
`root` - bütün faylların yerləşdiyi əsas qovluq.
`index` - əgər URI-də fayl göstərilməyibsə, default olaraq index.html verilsin.


#location /languages

```nginx
location /languages {
    root "C:\\Users\\mahammada\\Documents\\test-nginx";
}
```

Burda deyirəm ki, `/languages` çağıranda `root` qovluğunun içindəki `languages` kataloqunu göstər.

Məsələn: `http://localhost/languages/` gedəndə, 
Nginx `...\test-nginx\languages\index.html` axtarır.


#location /lang (redirect nümunəsi)

```nginx
location /lang {
    return 307 /languages;
}
```

Burda artıq başqa cür eləmişəm. `/lang` çağıranda Nginx heç fayl axtarmır, 
sadəcə redirect edir `/languages`-ə.

307 HTTP status kodudur. 
Bu o deməkdir ki: brauzer `/lang` açanda avtomatik `/languages`-ə yönləndiriləcək.


#location /names (try\_files nümunəsi)

```nginx
location /names {
    root "C:\\Users\\mahammada\\Documents\\test-nginx";
    try_files /names/randomizednames.html /index.html =404;
}
```

Burda maraqlı nümunə var: `try_files`.

Qayda belədir: `/names` açanda əvvəl `randomizednames.html` axtar. 
Tapmasa `index.html` ver. 
O da tapılmasa, 404 qaytar.

Yəni “try\_files” - addım-addım variantları yoxlamaqdır. 
Bu məntiq çox vaxt SPA (Blazor, React, Vue) üçün istifadə olunur: 
“fayl yoxdursa, index.html ver, router özü həll eləsin”.


#location \~\* /count/\[0-9] (regex nümunəsi)

```nginx
location ~* /count/[0-9] {
    root "C:\\Users\\mahammada\\Documents\\test-nginx";
    try_files /index.html =404;
}
```

Burda `~*` yazanda regex işləyir.

Qayda: `/count/`-dan sonra rəqəm varsa, bu işləsin.

* `http://localhost/count/5` → index.html verilir.
* `http://localhost/count/abc` → uyğun gəlmir, default qaydalar işləyir.

Yəni regex ilə çox çevik qaydalar yazmaq mümkündür.


Mənim nəticəm - dərs kimi

1. Nginx web serverdir - HTTP sorğularını qəbul edir və faylları qaytarır.
2. Root - əsas kataloqdur, yəni hansı qovluqdan fayl göstəriləcək.
3. Index - default fayldır (adətən index.html).
4. Location - xüsusi yollar üçün qaydadır:

   * `/languages` → root-dakı languages qovluğunu göstər.
   * `/lang` → 307 redirect et `/languages`-ə.
   * `/names` → try\_files ilə ardıcıl yoxla.
   * `~* /count/[0-9]` → regex əsasında qayda yaz.
5. mime.types - faylların Content-Type başlıqlarını düzgün təyin edir 
(html → text/html, css → text/css və s.).


----------------------------------------------------

2. Sıxılma nə üçündür?

Brauzer serverdən fayl alanda, əgər fayl sıxılmamış gəlirsə, hər dəfə daha çox MB ötürülür. 
Xüsusilə JS, CSS, HTML və .wasm faylları böyük ola bilər. 
Əgər gzip və ya brotli ilə sıxılsa, şəbəkədən daha az ölçüdə gedir və brauzer özü açır.

Məsələn:

app.js faylın 500 KB-dır.
gzip ilə sıxsan → 150 KB.
brotli ilə sıxsan → 120 KB.
Yəni brauzerə 3-4 dəfə daha az data gəlir. Bu həm istifadəçi üçün sürət, həm də server üçün yükün azalmasıdır.


2.1. gzip necə aktivləşdirilir?
Nginx-də gzip çox sadə açılır. Konfiqurasiya belədir:

http {
    gzip on;                         # gzip-i açırıq
    gzip_min_length 1024;            # minimum fayl ölçüsü (1 KB-dan böyük olsun)
    gzip_types text/plain text/css application/json application/javascript application/xml application/wasm;
}

Burada gzip_types – hansı fayl tiplərinə tətbiq olunacağını göstərir. Əsas olanlar: html, css, js, json, xml, wasm.
http://localhost/index.html gələndə, server cavabı header-larda belə görünür:

Content-Encoding: gzip

Qeyd: əgər həm gzip, həm brotli açıqdırsa, brauzer hansını dəstəkləyirsə, onu seçir. 
Yəni brauzer sorğuda Accept-Encoding: br, gzip yazırsa, Nginx brotli ilə cavab verir.


--------------------------------------------------

3. Niyə caching vacibdir?

Blazor WASM və ümumiyyətlə hər SPA tətbiqində yüzlərlə JS, CSS, .wasm faylı olur. 
Əgər brauzer hər dəfə serverdən bunları yükləsə, həm serverin yükü artır, həm də istifadəçi üçün sayt yavaş açılar. 
Amma fayllar dəyişmirsə (məsələn, app.bundle.12345.js), brauzer onları 1 il yadda saxlasın, yalnız dəyişəndə yenisini götürsün.

3.1. Buna görə cache control iki məqsəd daşıyır:

Sabit fayllar – uzun müddət yadda saxlanılır.
Dinamik fayllar (index.html, API cavabları və s.) – tez-tez yenilənir, ona görə cache azaldılır və ya söndürülür.



3.2. Nginx-də caching necə yazılır?
Konfiqurasiya nümunəsi belədir:

server {
  listen 80;
  server_name localhost;

  root /usr/share/nginx/html;
  index index.html;

  # 1) Uzunmüddətli cache-lənəcək aktivlər
  location ~* \.(?:js|css|png|jpg|jpeg|gif|ico|svg|woff2?|ttf|eot|wasm)$ {
    expires 1y;
    add_header Cache-Control "public, immutable";
  }

  # 2) SPA giriş faylı hər dəfə yoxlanılsın
  location = /index.html {
    expires -1;
    add_header Cache-Control "no-cache, must-revalidate";
  }

  # 3) SPA fallback: fayl tapılmasa index.html verilsin
  location / {
    try_files $uri $uri/ /index.html;
  }
}


Caching davranışını iki yerə bölürük: 

1. statik aktivlər və 2. index.html. 

Statik aktivlər üçün yazdığımız location ~* \.(?:js|css|png|jpg|jpeg|gif|ico|svg|woff2?|ttf|eot|wasm)$ regex təyinatıdır. 
Burada ~* “case-insensitive” regex deməkdir; yəni .CSS və ya .Css görünsə də uyğun sayılacaq. 
\. nöqtənin özünü ifadə edir (regex-də nöqtə “istənilən simvol” deməkdir, ona görə qaçırdıq). 
Sonra gələn (?:js|css|...) qrup seçmədir; 

Bu blokun içində iki başlıq var: expires 1y və Cache-Control: public, immutable. 

expires 1y serverin cavabına köhnə tip Expires başlığını (indiki tarixdən +1 il) əlavə edir; 


location = /index.html sətirindəki = “tam bərabər uyğunluq”dur; bu, ən yüksək prioritetli location növüdür və məhz yalnız /index.html üçün işləyir. 
Burada expires -1 deyərək Expires başlığını keçmişə qoyuruq (praktik effekti “cache etmə” deməkdir), 
Cache-Control: no-cache, must-revalidate isə brauzerə “hər dəfə serverlə məsləhətləş” mesajını verir. 

“no-cache” “heç vaxt saxlamama” demək deyil; “istifadədən əvvəl serverdən soruş” deməkdir. “no-store” desəydik, brauzer diskdə saxlamazdı, 
amma bu da hər dəfə tam yükləmə demək olardı; SPA üçün adətən gərəksizdir. “must-revalidate” aralıq proxy-lərə “mütləq serverlə yoxla” deyir. 

Nəticə belə olur: istifadəçi saytı yenidən açanda brauzer əvvəlcə index.html üçün şərtli sorğu göndərir (If-None-Match/If-Modified-Since), 
server dəyişməyibsə 304 Not Modified qaytarır, əks halda yeni index gəlir və yeni bundle adları ilə resursları yenidən çəkir.

Üçüncü location SPA fallback üçündür. try_files $uri $uri/ /index.html ardıcıllıqdır: 
əvvəl real faylı yoxlayırıq, sonra qovluq kimi yoxlayırıq, heç biri yoxdursa index.html veririk. 



Dockerfile Client
--------------------------------------------------

# Build stage
FROM mcr.microsoft.com/dotnet/sdk:9.0 AS build
WORKDIR /src

# Copy the solution file
COPY ./src/client/ClientSolution.sln ./client/

# Copy csproj files
COPY ./src/shared/LearnKazakh.Shared/*.csproj ./shared/LearnKazakh.Shared/
COPY ./src/client/*.csproj ./client/

# Restore dependencies for ALL projects
RUN dotnet restore ./client/ClientSolution.sln

# Copy the rest of the source code
COPY ./src/shared ./shared/
COPY ./src/client ./client/

# Publish stage: Publish API project
RUN dotnet publish ./client/ClientSolution.sln -c Release -o /app/publish/ --no-restore

# Runtime stage
FROM nginx:alpine AS runtime

# Copy custom nginx config
COPY ./docker/nginx.conf /etc/nginx/nginx.conf
RUN rm /etc/nginx/conf.d/default.conf

# COPY ./docker/default.conf /etc/nginx/conf.d/default.conf

# Copy published app to nginx web directory
COPY --from=build /app/publish/wwwroot /usr/share/nginx/html

CMD ["nginx", "-g", "daemon off;"]


--------------------------------------------------

/usr/share/nginx/html Nginx imiclərində defolt veb kökdür. 
Nginx “fayl verən server” kimi çalışanda root direktivi ilə göstərilən path'dən fayl oxuyur. 
Blazor WASM publish-dən çıxan wwwroot məzmununu məhz buna görə /usr/share/nginx/html altına kopyalayasan. 

Blazor müştəri tərəfi sırf HTML, CSS, JS, wasm fayllarıdır; 


/etc/nginx/nginx.conf isə Nginx-in əsas konfiqurasiya faylıdır. 
Nginx-in konfiqurasiya iyerarxiyası belə işləyir: 

əsas fayl nginx.conf içində “main”, events və http kontekstə sahib olur, http içində bir və ya bir neçə server bloku, 
onların içində də location qaydaları yerləşir.

