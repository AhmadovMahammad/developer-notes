2. Docker CLI məntiqi: imajlar, konteynerlər, laylar, keş
---------------------------------------------------------

------------------------------------------------------------------------------------------------------------
2.1. Image adı necə qurulur?

Image üçün 4 əsas əməliyyat var: pull, build, tag, push. Hərəsi eyni obyekt üzərində fərqli mərhələdir:
registry-dən gətirmək, sıfırdan yaratmaq, ad vermək, registriyə yollamaq.

1. Image adı necə qurulur?
Bir image-in adı həmişə üç hissədən ibarət olur:

[registry]/[repo adı]:[tag]

registry – image haradan gəlir (məsələn, docker.io → Docker Hub). Yazmasan default olaraq Docker Hub götürülür.
repo adı – layihənin və ya proqramın adı (ubuntu, nginx, microsoft/dotnet).
tag – versiya işarəsi (20.04, 9.0, latest).


Məsələn: docker pull ubuntu:20.04
Bu əmrlə sən Docker Hub-dan (registry) ubuntu repozitoriyasının 20.04 tag-lı image-in çəkirsən.


Qeydlər:
Əgər :tag yazmasan → avtomatik :latest gəlir. Amma “latest” heç vaxt zəmanət deyil, sadəcə bir etiketdir. Sabah dəyişə bilər.
Həqiqi dəyişməz identifikator isə digest-dir. Digest sha256:xxxx... formasında olur. Digest ilə çəkilən (pull edilən) image hər yerdə eyni baytları gətirir.


Pull əməliyyatı əslində nə edir?
Məsələn, sən yazırsan: docker pull nginx:1.25
Arxada addım-addım bunlar olur:

1. Client → Daemon
Sənin docker əmrini yazmağın sadəcə client-dir. O, arxa plandakı dockerd-ə deyir: “nginx:1.25 image-ni çək (pull)”.

2. Manifest istənilir
Docker daemon Docker Hub API-yə sorğu göndərir və deyir: “Bu ad və tag üçün manifest ver”.
Manifest sadəcə “bu image neçə laydan ibarətdir, hər layın hash-ı və ölçüsü nədir” siyahısıdır.

3. Layların yoxlanması
Daemon əvvəl lokaldakı store-a baxır: bu hash-lı lay artıq varmı? 
Əgər var, yenidən endirmir. Əgər yoxdur, həmin layı registridən çəkir.

Məsələn:
Ən altda debian:bookworm-slim bazası.
Üstündə nginx serverin faylları.

4. Layların yığılması
Laylar endirilib dekompress edilir və lokal store-a yazılır.

5. İstifadəyə hazır olur
İndi sən docker run nginx:1.25 desən, həmin laylardan root filesystem hazırlanacaq və konteyner işə düşəcək.



Platforma məsələsi
Bəzən eyni ad altında fərqli arxitektura imajlar olur. Məsələn, nginx:1.25 həm linux/amd64, həm də linux/arm64 üçün mövcuddur.

Əgər sənin kompüterin amd64-dür, Docker uyğun olan manifesti seçəcək.
Əgər sən ARM cihazındasan (məsələn, Apple M1/M2), Docker oradakı arm64 qatını çəkəcək.
Əgər xüsusi olaraq amd64 istəyirsənsə, belə yaza bilərsən:

docker pull --platform linux/arm64 nginx:1.25
------------------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------------------
2.2. Build – sıfırdan image yaratmaq

“Build” dedikdə məqsəd odur ki, kodunu və ona lazım olan faylları götürüb dəyişməz bir image-ə çevirəsən.
Bu image sabit olacaq, yəni eyni Dockerfile və eyni fayllarla yenidən quranda eyni nəticəni verəcək.
Bunun üçün iki anlayışı bir yerdə başa düşmək kifayətdir: 1. build konteksti və 2. Dockerfile.


Build konteksti sənin göndərdiyin iş qovluğudur. docker build -t myapp:1.0 . yazanda sondakı nöqtə həmin qovluq deməkdir. 
Docker client bu qovluğu arxivləyib daemon-a ötürür. Kontekstdə nə varsa, hash hesabına daxil olur. 
Ona görə lazımsız və iri qovluqları konteksdən kənar saxlamaq vacibdir. 
Bunun üçün kökdə .dockerignore faylı saxlayırsan. 
Məsələn, .NET layihəsində bin, obj, .vs, .git və oxşar kataloqları .dockerignore-a yazırsan ki, hər build-də bu tonlarla fayl göndərilməsin və 


Dockerfile sənin “reseptindir”. Docker onu sətir-sətir oxuyur, hər sətir deterministik bir addımdır və nəticəsi ayrı bir lay kimi yadda qalır. 
Eyni sətir eyni giriş faylları ilə təkrar gəlirsə, Docker layı keşdən götürür və vaxt itirmir. 
Buna görə sətir sırası performansdır. 
Nadir dəyişən addımlar yuxarıda, tez-tez dəyişən addımlar altda olmalıdır.


--------------------------------------------------------------------------------------------------------------------------------------------------------------------
Sadə bir .NET Web API nümunəsi üzərindən sıfırdan quraq. Kökdə src/MyApi.csproj, src/Program.cs və s. var. .dockerignore da kökdədir və lazımsız qovluqları çıxarıb.

# 1) Build mərhələsi: ağır SDK imajı içində publish
FROM mcr.microsoft.com/dotnet/sdk:9.0 AS build
WORKDIR /src

# Restore-un keşlənməsi üçün əvvəlcə yalnız layihə təsvirlərini kopyala
COPY ./src/*.csproj ./
RUN dotnet restore

# İndi qalan kodu gətir və publish et
COPY ./src/. .
RUN dotnet publish -c Release -o /out --no-restore

# 2) Run mərhələsi: yüngül runtime imajı, yalnız artefaktlar
FROM mcr.microsoft.com/dotnet/aspnet:9.0 AS runtime
WORKDIR /app
COPY --from=build /out ./
ENV ASPNETCORE_URLS=http://+:8080
EXPOSE 8080
ENTRYPOINT ["dotnet", "MyApi.dll"]

Konteksin təmiz qalması üçün kökdə belə bir .dockerignore saxla:
**/bin
**/obj
**/.vs
**/*.user
**/*.suo
.git
.gitignore
*.md
*.log
node_modules
--------------------------------------------------------------------------------------------------------------------------------------------------------------------

Birinci hissə dotnet restore-un SDK mərhələsində nə iş gördüyüdür. 
dotnet restore layihə faylındakı (*.csproj) NuGet dependecyleri həll edir, yəni hansı paketlərin hansı dəqiq versiyaları lazım olduğunu müəyyənləşdirir, 


1. Docker-da RUN əmrləri və cache
Dockerfile-ı oxuyanda hər sətir (RUN, COPY, ADD, və s.) yeni bir qat (layer) yaradır.

: Docker hər qatın girişini (hansı fayllar konteksdən kopyalandı + əmrin özü) hash-layır.
: Əgər həmin hash eyni qalırsa, Docker əvvəlki nəticəni (cache) istifadə edir.
: Əgər hansısa giriş dəyişibsə (məsələn, kopyalanan fayl dəyişdi, ya da əmrin özü dəyişdi), onda həmin qat yenidən icra olunur və nəticə yeni qat kimi saxlanılır.

RUN dotnet restore
qatının cache-də qalması üçün bu əmrin girişləri eyni olmalıdır. Onun girişləri nədir?

1. Ondan əvvəlki qatın faylları (biz COPY ilə yalnız *.csproj gətirmişik).
2. Əmr mətninin özü (“dotnet restore”). 

Əgər .csproj faylları dəyişməyibsə və əmr də eynidirsə → Docker görür ki, “bu qatın nəticəsi artıq var” və təkrar işləmir, cache-dən götürür.


2. Niyə restore-u koddan əvvəl edirik?
Əgər sən əvvəlcə bütün kodu COPY . . ilə gətirsən və sonra RUN dotnet restore desən:

1. Kodda hər xırda dəyişiklik (məsələn, Program.cs-də bir sətir) COPY qatını dəyişəcək.
2. O zaman həmin qatın digest-i dəyişəcək və ondan sonra gələn bütün qatların cache-i pozulacaq, yəni restore da təkrar icra olunacaq.
Halbuki NuGet paketləri heç dəyişməyib.

Bu səbəbdən restore-u .csproj-ları kopyalayandan dərhal sonra edirik. .csproj-lar nadir dəyişir, ona görə bu qat çox vaxt cache-dən gəlir. 
Kod isə ayrı COPY ilə sonradan gətirilir. Beləliklə, kod dəyişəndə yalnız publish qatı pozulur, restore qatının cache-i qorunur.


3. “no-restore” nə üçündür?

Sən dotnet publish yazanda əslində o, default olaraq əvvəlcə restore edir, sonra publish. 
Amma biz artıq restore-u ayrıca etmişik və cache-də saxlamışıq. 
Ona görə publish-də --no-restore yazırıq. Bu, “yenidən paketləri yoxlama, keçmiş qatdakı restore nəticəsindən istifadə et” deməkdir.

Əgər --no-restore yazmasan, publish hər dəfə restore etməyə çalışacaq → cache mexanikasının qazancı gedəcək.

--------------------------------------------------

İkinci hissə .dockerignore-un nə iş gördüyüdür. 
Docker build vaxtı nöqtə (.) ilə göstərdiyin qovluq arxivlənib daemon-a göndərilir; buna build konteksti deyirik. 
.dockerignore bu arxivə daxil olmayacaq fayl və qovluqları sadə pattern-lərlə çıxarır. 
Məna çox sadədir: nə qədər az lazımsız fayl göndərsən, bir o qədər az hash dəyişər və cache qorunar.

.dockerignore yalnız build kontekstdən çıxarır; lokal diskindəki fayllar silinmir. Nəticədə build sürətlənir.

--------------------------------------------------

Üçüncü hissə docker build komandası və flaqların mənasıdır. 

Əsas forma belədir: docker build -t myapi:1.0 . 

Burada -t image-ə ad və tag verir; bu ad sonradan run, tag, push üçün kimlikdir. Nöqtə build kontekstidir. 
Başqa fayl adı ilə build etmək istəsən -f Dockerfile.prod deyərsən.

məsələn:
Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
-a---          29.08.2025    15:33             76 .dockerignore
-a---          30.08.2025    23:12              0 docker-compose-prod.yml
-a---          30.08.2025    23:12              0 docker-compose.yml
-a---          30.08.2025    23:11              0 Dockerfile.api
-a---          30.08.2025    23:11              0 Dockerfile.client

Biz burada Dockerfile.api və ya Dockerfile.client istifadə edə bilərik.

--------------------------------------------------

Əvvəlcə “build konteksti” ilə “WORKDIR” arasındakı fərqi qısaca yerləşdirim ki, qalan hamısı aydın olsun. 
1. Build konteksti sənin hostdakı iş qovluğundur; docker build ... . yazanda sondakı nöqtə həmin qovluğu daemon-a göndərmək deməkdir. 

2. WORKDIR isə imajın içində “hazırda işlədiyim qovluq” deməkdir. 
Yəni COPY A B əməlində A hostdakı kontekstdədir, B isə imajın içindədir və WORKDIR-ə nisbidir. 
Bu ikisi eyni şey deyil: biri kənardakı material, digəri konteynerin içində istifadə edilən ünvan anlayışıdır.


Sənin həndəsənə görə ən rahat yol Dockerfile-ı repozitoriyanın kökünə qoyub build kontekstini də kök qovluq etməkdir. 
Onda src/... yollarını birbaşa COPY edə biləcəyik. .dockerignore da elə kökdə durmalıdır. Bu .dockerignore Docker-a “kontekstə bunları qatma” siyahısı verir. 
Fayllar diskindən silinmir, sadəcə build üçün arxivə düşmür. Nəticə ikiqatdır: göndərilən material balacalaşır, COPY . . kimi sətirlərin hash-ı xırda səbəblərlə dəyişməyib cache pozulmur.


-------------------------
# Build stage
FROM mcr.microsoft.com/dotnet/sdk:9.0 AS build
WORKDIR /src

# Copy solution file
COPY ./src/server/ApiSolution.sln ./server/

# Copy csproj files
COPY ./src/shared/LearnKazakh.Shared/*.csproj         ./shared/LearnKazakh.Shared/
COPY ./src/server/LearnKazakh.API/*.csproj            ./server/LearnKazakh.API/
COPY ./src/server/LearnKazakh.Application/*.csproj    ./server/LearnKazakh.Application/
COPY ./src/server/LearnKazakh.Core/*.csproj           ./server/LearnKazakh.Core/
COPY ./src/server/LearnKazakh.Domain/*.csproj         ./server/LearnKazakh.Domain/
COPY ./src/server/LearnKazakh.Infrastructure/*.csproj ./server/LearnKazakh.Infrastructure/
COPY ./src/server/LearnKazakh.Persistence/*.csproj    ./server/LearnKazakh.Persistence/

# Restore dependencies for ALL projects
RUN dotnet restore ./server/ApiSolution.sln

# Copy the rest of the source code
COPY ./src/server ./server/
COPY ./src/shared ./shared/

# Publish stage: Publish API project
RUN dotnet publish ./server/LearnKazakh.API/LearnKazakh.API.csproj -c Release -o /out --no-restore

# Runtime stage
FROM mcr.microsoft.com/dotnet/aspnet:9.0 AS runtime
WORKDIR /app

# Copy published app
COPY --from=build /out ./

ENV ASPNETCORE_URLS=http://+:8080
EXPOSE 8080

ENTRYPOINT ["dotnet", "LearnKazakh.API.dll"]
-------------------------

docker build -t test-api-image:1.0 . -f .\docker\Dockerfile.api
docker faylından yeni image yaradır

powershell command: [docker image ls]

REPOSITORY       TAG       IMAGE ID       CREATED          SIZE
test-api-image   1.0       974ad39e9d51   36 minutes ago   387MB



